---
title: "#30diasdegraficos Parte 2"
description: |
  La segunda parte, A seguir aprendiendo sobre todas las posibilidades que 
  highcharts a través de R nos puede brindar.
author:
  - name: Joshua Kunst
    url: http://jkunst.com/
date: "`r format(Sys.time(), '%m-%d-%Y')`"
output:
  distill::distill_article:
    self_contained: true
    toc: true
categories: 
  - spanish
  - highcharts
  - data-visualization
  - ggplot2
editor_options: 
  chunk_output_type: console
preview: images/preview.png
---


```{r setup, include=FALSE}
source(here::here("_R/blog_setup.R"))
knitr::opts_chunk$set(layout = "l-body-outset")
```

## Introducción

Seguiremos utilizando los mismos paquetes que la parte anterior.

```{r}
# ejecutar estas líneas para poder instalar {datos}
# install.packages("remotes")
# remotes::install_github("cienciadedatos/datos")

library(datos)       # datos
library(highcharter) # gráficos
library(ggplot2)     # más gráficos  
library(dplyr)       # manipulación de datos
library(tidyr)       # más manipulación de datos
```

Cambiando configuración para el español.

```{r}
newlang_opts <- getOption("highcharter.lang")

f <- Sys.Date()
dias <- weekdays((f - lubridate::days(lubridate::wday(f) - 1)) + lubridate::days(0:6))

newlang_opts$weekdays <- dias
newlang_opts$months <- as.character(lubridate::month(1:12, label = TRUE, abbr = FALSE))
newlang_opts$shortMonths <- as.character(lubridate::month(1:12, label = TRUE, abbr = TRUE))
newlang_opts$thousandsSep <- ","

options(highcharter.lang = newlang_opts)
```


## Día 11: mapas de calor

Mapa de calor. Usualmente se utiliza para visualizar relaciones entre dos
variables categorícas (o 2 contínuas categorizandolas). En este ejemplo
utilizaremos día y hora como una variables "numericas discretas". 

Caso de `heatmaps` son los visualizar distancia entre observaciones/individuos.

```{r}
mtautos2 <- mtautos[1:20, ]
matriz_distancias <- dist(mtautos2)

hchart(matriz_distancias) %>% 
  hc_title(text = "Distancia entre características de los vehículos")
```

Y también explorar correlaciones:

```{r}
hchart(cor(mtautos))
```

**Medio/Avanzado**. Es la implementación de este ejemplo 
https://www.highcharts.com/demo/heatmap-canvas. Notar la relación de 
opciones en HighchartsJS y {highcharter}.

```{r heatmap, layout="l-screen-inset"}
# install.packages("aimsir17")
library(lubridate)

data(observations, package = "aimsir17")

temperaturas <- observations %>% 
  filter(station == "KNOCK AIRPORT") %>% 
  select(fecha = date, hora = hour, temperatura = temp) %>% 
  mutate(fecha = as.Date(fecha))

# temperaturas %>% 
#   count(fecha, hora) %>% 
#   count(n)

hc11 <- hchart(
  temperaturas,
  "heatmap",
  hcaes(datetime_to_timestamp(fecha), hora, value = temperatura),
  colsize =  36e5 * 24 # 1 hour * 24 = 1 day
  ) %>%
  hc_title(text = "Temperaturas del aeropuerto Knock") %>%
  hc_subtitle(text = "Datos obtenidos del paquete {aimsir17}.") %>%
  hc_chart(zoomType = "x") %>%
  hc_xAxis(
    type = "datetime",
    title = list(text = FALSE),
    showLastLabel = FALSE
    ) %>%
  hc_yAxis(
    minPadding = 0,
    maxPadding = 0,
    startOnTick = FALSE,
    endOnTick = FALSE,
    tickPositions = list(0, 6, 12, 18, 24),
    tickWidth = 1,
    min = 0,
    max = 23,
    reversed = TRUE,
    labels = list(format = "{value}:00"),
    title = list(text = FALSE)
  ) %>%
  hc_tooltip(
    headerFormat = "Temperatura<br/>",
    pointFormat =  "{point.x:%e %b, %Y} {point.y}:00: <b>{point.value} ℃</b>"
  ) %>%
  hc_colorAxis(
    stops = color_stops(10, colors = scales::viridis_pal(option = "B")(10)),
    # fuerza a utilzar mejor el espectro de colores para que HJS no amplie el
    # eje para tener numero "redondos
    startOnTick = FALSE,
    endOnTick =  FALSE
  ) %>%
  hc_legend(
    align = "right",
    layout = "vertical",
    verticalAlign = "top"
   )

hc11
```


## Día 12: paleta (lillipop)

Gráfico que se utiliza en forma general para describir una variable numérica
para un set de individuos/registros (a diferencia de gráfico de barra que 
usualmente se utiliza sumando cantidades por categoría).

Los datos a utilizar son `mtautos` del paquete {datos} pero pasando 
algunas variables a las métricas que usualemente utilizamos: libras a kilos,
pulgadas cúbicas a centímeotrs cúbicos, etc.

```{r}
mtautos2 <- as_tibble(mtautos) %>% 
  mutate(auto = rownames(mtautos)) %>% 
  arrange(desc(caballos)) %>% 
  mutate(
    auto = forcats::fct_inorder(factor(auto)),
    peso_kg = round(0.4535923 * peso * 1000),
    cilindrada_cc = round(16.387 * cilindrada)
    ) 
  
mtautos2
```

La implementación en {highcharter} es directa, solamente usar el mapeo 
de `name` para la variable categórica y `low` para la numérica (`low` 
dado que esta es una modificación del gráfico de dumbbell que utiliza además
`high`).

**Basico/Medio**. En esta oportunidad haremos un tooltip de tipo tabla con
el fin de mostrar más información que los HP de cada vehículo. Para esto 
usaremos la función auxiliar `tooltip_table` en el argumento `pointFormat`.

```{r}
x <- c("Caballos:", "Peso", "Cilindrada")
y <- c(
  "{point.y} HP",
  "{point.peso_kg} kg",
  "{point.cilindrada_cc} cc"
)

hc12 <- hchart(mtautos2, "lollipop", hcaes(name = auto, low = caballos), name = "caballos (HP)") %>% 
  hc_xAxis(type = "category") %>% 
  hc_yAxis(labels = list(format = "{value} HP")) %>% 
  hc_tooltip(
    useHTML = TRUE,
    pointFormat = tooltip_table(x, y)
    ) %>% 
  hc_title(
    text = "Caballos de fuerza para autómóviles de Motor Trend"
  ) %>% 
  hc_subtitle(
    text = "Los datos fueron extraídos de la revista Motor Trend de Estados 
    Unidos de 1974, y tiene datos de consumo de combustible y 10 aspectos de diseño 
    y rendimiento para 32 automóviles (modelos de 1973-1974)."
  )

hc12
```

## Día 13: visualizar datos temporales

Notar que el último gráfico del [día 11](#día-11-mapas-de-calor) es un caso 
particular de de visualizar datos temporales.

Usualmente en **R** los datos temporales o serie de tiempo vienen en un 
objecto de clase `ts` (time series) que básicamente son valores numéricos
asociado a una fecha (o índice). Notar que también datos temporales pueden
perfectamente almacenarse en un `data.frame`, nota los datos `observations`
del [día 11](##día-11-mapas-de-calor). 

Para grafica objectos de clase `ts` en {highcharter} es bastante directo
dado que `hchart` es una **función genérica**. Esto significa que la
función dependiendo de la clase del objeto la interpretará/graficará de la 
forma que corresponde. Por ejemplo `ts` y `data.frame` son clases que la
función `hchart` reconoce, y existen muuuchas más clases que `hchart` puede
interpretar, intenta correr `methods("hchart") ` para listar todas las clases
que actualmente esta función soporta.

Volviendo a nuestro gráfico en **R** existe los datos `co2` que son una
serie de tiempo (clase `ts`).

```{r}
data(co2)

str(co2)

hc13 <- hchart(co2, name = "Concentración") %>% 
  hc_title(
    # para poder usar el tag html "sub" para subindices
    useHTML = TRUE,
    text = "Concentración atomsférica de CO<sub>2</sub> en Mauna Loa"
  ) %>% 
  hc_subtitle(
    text = "Las concentraciones atmosféricas de CO2 se expresan en partes por 
    millón (ppm) y se informan en la escala preliminar de fracción molar
    manométrica SIO de 1997."
  )

hc13
```

Aprovechando que estamos revisando series de tiempo, podemos hacer una
descomposición usando Loess (suavizamiento). La función `stl` toma un
serie de tiempo descomponiéndola en **tendencia**, **componente estacional** y
**ruido**.

Como veremos, el gráfico se realiza simplemente como `hchart(descomposicion)`:

```{r, }
descomposicion <- stl(co2, "per")

hc132 <- hchart(descomposicion) %>% 
  hc_tooltip(valueDecimals = 2) %>% 
  hc_title(
    useHTML = TRUE,
    text = "Descomposición de la Concentración atomsférica de CO<sub>2</sub> en
    Mauna Loa utilizando la funcion <code>stl</code>"
  ) %>% 
  hc_subtitle(
    text = "<b>Descripción del comando <code>stl</code></b>:
    El componente estacional se encuentra al suavizar loess la sub-serie
    estacional (la serie de todos los valores de enero, ...); si s.window = 
    'periódico' suavizado se reemplaza efectivamente tomando la media. Los 
    valores estacionales se eliminan y el resto se suaviza para encontrar la 
    tendencia. El nivel general se elimina del componente estacional y se agrega
    al componente de tendencia. Este proceso se repite varias veces. El componente
    restante son los residuos del ajuste estacional más tendencial."
  ) %>% 
  hc_tooltip(table = TRUE) %>% 
  hc_size(height = "700px")

hc132
```

Para finalizar ejemplificaremos la integración de {highcharter} con el paquete
{forecast} con el cual se puede realizar predicciones de los datos de forma
simple.

```{r}
library(forecast)

pronosticos <- forecast(ets(USAccDeaths), h = 48, level = 95)

hc133 <- hchart(pronosticos) %>% 
  hc_title(
    text = "Muertes por accidentes en los EE. UU. 1973–1978 más predicciones
    generadas utilizando {forecast}"
  ) %>% 
  hc_tooltip(shared = TRUE, valueDecimals = 2)

hc133
```


## Día 14: treemaps

Es un buen gráfico para sustituir el gráfico de barras cuando las categorías
aumentan pues 

```{r}
library(forcats) # para usar la función fct_inorder

conteo_clases <- count(millas, clase)
conteo_clases

hchart(
  conteo_clases,
  "treemap",
  hcaes(clase, value = n, colorValue = n),
  borderColor = NA # elimina border y se tiene un aspecto más limpio imho
  ) %>% 
  hc_colorAxis(stops  = color_stops()) %>% 
  hc_title(text = "Conteo de tipos de automóviles en los datos 'millas'") %>% 
  hc_colorAxis(endOnTick = FALSE)
```


**Avanzado** Trabajo en progreso!

```{r}
library(readr)

url_base <- "https://raw.githubusercontent.com/PokeAPI/pokeapi/master/data/v2/csv"
pkmn <- read_csv(file.path(url_base, "pokemon.csv"))

pkmn_nombre_tipos <- read_csv(file.path(url_base, "type_names.csv")) %>% 
  # inglés es 9, Japonez es 1, español 7
  filter(local_language_id == 9)

pkmn_tipo <- read_csv(file.path(url_base, "pokemon_types.csv"))
pkmn_tipo <- pkmn_tipo %>% 
  mutate(slot = paste0("type_", slot)) %>% 
  left_join(pkmn_nombre_tipos, by = "type_id") %>% 
  select(pokemon_id, slot, name) %>% 
  spread(slot, name)
```


```{r}
pkmn_colores_tipo <- pkmn_nombre_tipos %>% 
  pull(name) %>% 
  setdiff(c("???", "Shadow")) %>% 
  purrr::map_df(function(t){
  # t <- "psychic"
  message(t)
  
  col <- "http://pokemon-uranium.wikia.com/wiki/Template:%s_color" %>% 
    sprintf(t) %>%
    xml2::read_html() %>% 
    rvest::html_nodes("span > b") %>% 
    rvest::html_text()
  
  tibble(type = t, color = paste0("#", col))
})

pkmn_colores_tipo2 <- crossing(
  color_1 = pkmn_colores_tipo$color,
  color_2 = pkmn_colores_tipo$color
  ) %>% 
  mutate(
    color_f =
      purrr::map2_chr(
        color_1,
        color_2,
        ~ colorRampPalette(c(.x, .y))(100)[round(100 * .25)])
    )

# https://bulbapedia.bulbagarden.net/wiki/List_of_Pok%C3%A9mon_by_base_stats_(Generation_VIII-present)

pkmn <- pkmn %>% 
  left_join(pkmn_tipo, by = c("id" = "pokemon_id")) %>% 
  left_join(pkmn_colores_tipo %>% rename(type_1 = type, color_1 = color), by = "type_1") %>% 
  left_join(pkmn_colores_tipo %>% rename(type_2 = type, color_2 = color), by = "type_2") %>% 
  left_join(pkmn_colores_tipo2, by =  c("color_1", "color_2")) 

pkmn <- pkmn %>% 
   mutate(color_f = ifelse(is.na(color_f), color_1, color_f))
```

## Día 15: dendogramas

Los dendogramas son una 2da iteración a la visualización de distancia 
entre individuos o registros en una tabla como lo es el primer gráfico 
del [día 11](#día-11-mapas-de-calor). Los dendogramás son complejos de leer pues
traen mucha más información debido a que podemos ver como se van agrupando
(en términos de distancia) las observaciones. Que una esté cerca de otra
significa que sus carácterísticas son similares. 

Para gráficar en {highcharter} haremos ya el conocido truco de extraer la
información luego de generer un ggplot con la información. Un paquete 
para generar dendogramas usando {ggplot2} es {ggdendro}.

Los dendogramas salen como un resultado a partir de un "agrupamiento jerárquico"
que viene a su vez de una matriz de distancias, por lo que calcularemos
la clasterización antes de graficar el dendograma.

```{r}
# install.packages("ggdendro")
library(ggdendro)

hc <- hclust(dist(mtautos), "ave")

ggd <- ggdendrogram(hc, rotate=TRUE)

dd15 <- as_tibble(ggplot2::layer_data(ggd, 2))

dd152 <- dd15 %>% 
  select(x, xend, y, yend) %>% 
  mutate(id = row_number()) %>% 
  gather(key, value, -id) %>% 
  mutate(key = stringr::str_remove(key, "end")) %>% 
  group_by(id, key) %>% 
  mutate(id2 = row_number()) %>% 
  spread(key, value) %>% 
  ungroup() %>% 
  select(-id2) %>% 
  mutate_if(is.numeric, round, 3)

hc15 <- hchart(
  dd152,
  "line",
  # x - 1 pues al colocar categorúías 
  hcaes(x - 1, y, group = id),
  color = "red",
  showInLegend = FALSE
  ) %>% 
  # https://stackoverflow.com/questions/43638810/how-to-get-labels-from-hclust-result
  hc_xAxis(
    categories = hc$labels[hc$order], 
    title = list(text = "Vehículos")
    ) %>% 
  hc_yAxis(
    title = list(text = "Distancia"),
    endOnTick = FALSE,
    crosshair = TRUE
    ) %>% 
  hc_tooltip(
    headerFormat = "",
    pointFormat = "<b>x</b>: {point.x}<br><b>y</b>:{point.y}",
    valueDecimals = 2
    ) %>% 
  hc_title(
    useHTML = TRUE,
    text = "Dendograma en el dataset <code>mtautos</code>"
    )
  
hc15
```


